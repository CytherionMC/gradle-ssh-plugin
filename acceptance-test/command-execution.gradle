
feature('executing a command') {
    task 'executeCommand'
    category 'test'
}

task executeCommand << {
    def x = randomInt()
    def y = randomInt()
    def a = ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y"
        }
    }
    assert a as int == (x + y)
}


feature('execute a command with console logging to stdout') {
    task 'executeCommandWithLogging'
    category 'test'
}

task executeCommandWithLogging << {
    def x = randomInt()
    def y = randomInt()
    def a = ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y", logging: 'stdout'
        }
    }
    assert a as int == (x + y)
}


feature('executing commands sequentially') {
    task 'executeSequentially'
    category 'test'
}

task executeSequentially {
    finalizedBy 'cleanRemoteTemp'
    doLast {
        def x = randomInt()
        def y = randomInt()
        def pathA = remoteTempPath('A')
        def pathB = remoteTempPath('B')
        def a
        def b
        ssh.run {
            session(remotes.localhost) {
                execute "expr $x + $y > $pathA"
                execute "expr $x + `cat $pathA` > $pathB"
                a = execute "cat $pathA"
                b = execute "cat $pathB"
            }
        }
        assert a as int == (x + y)
        assert b as int == (x + x + y)
    }
}


feature('each command should have independent environment') {
    task 'testEnvironmentOfCommand'
    category 'test'
}

task testEnvironmentOfCommand << {
    def a = ssh.run {
        session(remotes.localhost) {
            execute "export testdata=dummy"
            execute 'echo "testdata is $testdata"'
        }
    }
    assert a == 'testdata is '
}


feature('executing a command with PTY allocation') {
    task 'executeCommandWithPty'
    category 'test'
}

task executeCommandWithPty << {
    ssh.run {
        session(remotes.localhost) {
            executeBackground("env | grep -v SSH_TTY")
            executeBackground("env | grep SSH_TTY", pty: true)
        }
        session(remotes.localhost) {
            execute("env | grep -v SSH_TTY")
            execute("env | grep SSH_TTY", pty: true)
        }
    }
}


feature('executing commands concurrently') {
    task 'executeConcurrently'
    category 'test'
}

task executeConcurrently {
    finalizedBy 'cleanRemoteTemp'
    doLast {
        def tempPath = remoteTempPath(name)
        ssh.run {
            // task should start sessions concurrently
            session(remotes.localhost) {
                executeBackground "sleep 2 && echo 2 >> $tempPath"
            }
            session(remotes.localhost) {
                executeBackground "sleep 3 && echo 3 >> $tempPath"
                executeBackground "sleep 1 && echo 1 >> $tempPath"
                executeBackground "echo 0 >> $tempPath"
            }
        }
        // all commands should be completed at this point
        def result = ssh.run {
            session(remotes.localhost) {
                execute("cat $tempPath")
            }
        }
        assert result.readLines() == ['0', '1', '2', '3']
    }
}


feature('handling failure of the remote command') {
    task 'failureStatus'
    category 'test'
}

task failureStatus << {
    try {
        ssh.run {
            session(remotes.localhost) {
                execute 'exit 1'
            }
        }
        assert false, 'an exception should be thrown'
    } catch(RuntimeException e) {
        assert e.localizedMessage.contains('status 1')
    }
}


feature('handling failure of the remote command in background') {
    task 'failureStatusInBackground'
    category 'test'
}

task failureStatusInBackground << {
    try {
        ssh.run {
            session(remotes.localhost) {
                executeBackground 'exit 1'
            }
        }
        assert false, 'an exception should be thrown'
    } catch (RuntimeException e) {
        assert e.localizedMessage == 'Error in background command execution'
    }
}


feature('write output of the command to a file') {
    task 'writeCommandOutput'
    category 'test'
}

task writeCommandOutput << {
    def x = randomInt()
    def y = randomInt()
    def tempFile = file(localTempPath())
    tempFile.withOutputStream { stream ->
        ssh.run {
            session(remotes.localhost) {
                execute "expr $x + $y", outputStream: stream
            }
        }
    }
    assert tempFile.text as int == (x + y)
}


feature('write output of the command to stdout') {
    task 'writeCommandOutputToStdout'
    category 'test'
}

task writeCommandOutputToStdout << {
    def x = randomInt()
    def y = randomInt()
    ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y", outputStream: System.out
        }
    }
}


feature('write error of the command to a file') {
    task 'writeCommandError'
    category 'test'
}

task writeCommandError << {
    def tempFile = file(localTempPath())
    tempFile.withOutputStream { stream ->
        ssh.run {
            session(remotes.localhost) {
                execute "cat hoge || true", errorStream: stream
            }
        }
    }
    assert tempFile.text.contains('hoge')
}
