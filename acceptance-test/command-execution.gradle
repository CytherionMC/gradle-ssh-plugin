
task('feature: execute a command') << {
    def x = randomInt()
    def y = randomInt()
    assert ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y"
        }
    } as int == (x + y)
}

task('feature: execute a command with console logging to slf4j') << {
    def x = randomInt()
    def y = randomInt()
    assert ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y", logging: 'slf4j'
        }
    } as int == (x + y)
}

task('feature: execute commands sequentially') << {
    def x = randomInt()
    def y = randomInt()
    def a
    def b
    ssh.run {
        session(remotes.localhost) {
            execute "mkdir -vp $remoteWorkDir"
            execute "expr $x + $y > $remoteWorkDir/A"
            execute "expr $x + `cat $remoteWorkDir/A` > $remoteWorkDir/B"
            a = execute "cat $remoteWorkDir/A"
            b = execute "cat $remoteWorkDir/B"
        }
    }
    assert a as int == (x + y)
    assert b as int == (x + x + y)
}

task('spec: each command should have independent environment') << {
    assert ssh.run {
        session(remotes.localhost) {
            execute "export testdata=dummy"
            execute 'echo "testdata is $testdata"'
        }
    } == 'testdata is '
}

task('feature: execute a command with PTY allocation') << {
    ssh.run {
        session(remotes.localhost) {
            executeBackground "env | grep -v SSH_TTY"
            executeBackground "env | grep SSH_TTY", pty: true
        }
        session(remotes.localhost) {
            execute "env | grep -v SSH_TTY"
            execute "env | grep SSH_TTY", pty: true
        }
    }
}

task('feature: execute commands concurrently') << {
    ssh.run {
        session(remotes.localhost) {
            execute "mkdir -vp $remoteWorkDir"
        }
    }
    ssh.run {
        // task should start sessions concurrently
        session(remotes.localhost) {
            executeBackground "sleep 2 && echo 2 >> $remoteWorkDir/result"
        }
        session(remotes.localhost) {
            executeBackground "sleep 3 && echo 3 >> $remoteWorkDir/result"
            executeBackground "sleep 1 && echo 1 >> $remoteWorkDir/result"
            executeBackground "echo 0 >> $remoteWorkDir/result"
        }
    }
    // all commands should be completed at this point
    def result = ssh.run {
        session(remotes.localhost) {
            execute "cat $remoteWorkDir/result"
        }
    }
    assert result.readLines() == ['0', '1', '2', '3']
}

task('spec: it should throw exception if the command returned error') << {
    try {
        ssh.run {
            session(remotes.localhost) {
                execute 'exit 1'
            }
        }
        assert false, 'an exception should be thrown'
    } catch(RuntimeException e) {
        assert e.localizedMessage.contains('status 1')
    }
}

task('spec: it should throw exception if the command returned error also on background') << {
    try {
        ssh.run {
            session(remotes.localhost) {
                executeBackground 'exit 1'
            }
        }
        assert false, 'an exception should be thrown'
    } catch (RuntimeException e) {
        assert e.localizedMessage == 'Error in background command execution'
    }
}

task('feature: write output of the command to a file') << {
    def x = randomInt()
    def y = randomInt()
    localWorkDir.mkdir()
    def resultFile = file("$localWorkDir/result")
    resultFile.withOutputStream { stream ->
        ssh.run {
            session(remotes.localhost) {
                execute "expr $x + $y", outputStream: stream
            }
        }
    }
    assert resultFile.text as int == (x + y)
}

task('feature: write output of the command to standard output') << {
    def x = randomInt()
    def y = randomInt()
    ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y", outputStream: System.out
        }
    }
}

task('feature: write error of the command to a file') << {
    localWorkDir.mkdir()
    def resultFile = file("$localWorkDir/result")
    resultFile.withOutputStream { stream ->
        ssh.run {
            session(remotes.localhost) {
                execute "cat hoge || true", errorStream: stream
            }
        }
    }
    assert resultFile.text.contains('hoge')
}
