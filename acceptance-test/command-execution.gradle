
feature('executing a command') {
    task 'executeCommand'
    category 'test'
}

task executeCommand(type: SshTask) {
    doFirst {
        ext.x = randomInt()
        ext.y = randomInt()
    }
    session(remotes.localhost) {
        ext.a = execute "expr $x + $y"
    }
    doLast {
        assert a as int == (x + y)
    }
}


feature('execute a command with console logging to stdout') {
    task 'executeCommandWithLogging'
    category 'test'
}

task executeCommandWithLogging(type: SshTask) {
    doFirst {
        ext.x = randomInt()
        ext.y = randomInt()
    }
    session(remotes.localhost) {
        ext.a = execute "expr $x + $y", logging: 'stdout'
    }
    doLast {
        assert a as int == (x + y)
    }
}


feature('executing commands sequentially') {
    task 'executeSequentially'
    category 'test'
}

task executeSequentially(type: SshTask) {
    finalizedBy 'cleanRemoteTemp'

    doFirst {
        ext.x = randomInt()
        ext.y = randomInt()
        ext.pathA = remoteTempPath('A')
        ext.pathB = remoteTempPath('B')
    }
    session(remotes.localhost) {
        execute "expr $x + $y > $pathA"
        execute "expr $x + `cat $pathA` > $pathB"
        ext.a = execute "cat $pathA"
        ext.b = execute "cat $pathB"
    }
    doLast {
        assert a as int == (x + y)
        assert b as int == (x + x + y)
    }
}


feature('each command should have independent environment') {
    task 'testEnvironmentOfCommand'
    category 'test'
}

task testEnvironmentOfCommand(type: SshTask) {
    session(remotes.localhost) {
        execute "export testdata=dummy"
        ext.a = execute 'echo "testdata is $testdata"'
    }
    doLast {
        assert a == 'testdata is '
    }
}


feature('executing a command with PTY allocation') {
    task 'executeCommandWithPty'
    category 'test'
}

task executeCommandWithPty(type: SshTask) {
    session(remotes.localhost) {
        executeBackground("env | grep -v SSH_TTY")
        executeBackground("env | grep SSH_TTY", pty: true)
    }
    session(remotes.localhost) {
        execute("env | grep -v SSH_TTY")
        execute("env | grep SSH_TTY", pty: true)
    }
}


feature('executing commands concurrently') {
    task 'executeConcurrently'
    category 'test'
}

task executeConcurrently(type: SshTask) {
    finalizedBy 'cleanRemoteTemp'

    doFirst {
        ext.tempPath = remoteTempPath(name)
    }
    // task should start sessions concurrently
    session(remotes.localhost) {
        executeBackground "sleep 2 && echo 2 >> $tempPath"
    }
    session(remotes.localhost) {
        executeBackground "sleep 3 && echo 3 >> $tempPath"
        executeBackground "sleep 1 && echo 1 >> $tempPath"
        executeBackground            "echo 0 >> $tempPath"
    }
    doLast {
        // all commands should be completed at this point
        def result = ssh.run {
            session(remotes.localhost) {
                execute("cat $tempPath")
            }
        }
        assert result.readLines() == ['0', '1', '2', '3']
    }
}


feature('handling failure of the remote command') {
    task 'failureStatus'
    category 'test'
}

task failureStatus << {
    try {
        ssh.run {
            session(remotes.localhost) {
                execute 'exit 1'
            }
        }
        assert false, 'an exception should be thrown'
    } catch(RuntimeException e) {
        assert e.localizedMessage.contains('status 1')
    }
}


feature('handling failure of the remote command in background') {
    task 'failureStatusInBackground'
    category 'test'
}

task failureStatusInBackground << {
    try {
        ssh.run {
            session(remotes.localhost) {
                executeBackground 'exit 1'
            }
        }
        assert false, 'an exception should be thrown'
    } catch (RuntimeException e) {
        assert e.localizedMessage == 'Error in background command execution'
    }
}


feature('write output of the command to a file') {
    task 'writeCommandOutput'
    category 'test'
}

task writeCommandOutput << {
    def x = randomInt()
    def y = randomInt()
    def tempFile = file(localTempPath())
    tempFile.withOutputStream { stream ->
        ssh.run {
            session(remotes.localhost) {
                execute "expr $x + $y", outputStream: stream
            }
        }
    }
    assert tempFile.text as int == (x + y)
}


feature('write output of the command to stdout') {
    task 'writeCommandOutputToStdout'
    category 'test'
}

task writeCommandOutputToStdout << {
    def x = randomInt()
    def y = randomInt()
    ssh.run {
        session(remotes.localhost) {
            execute "expr $x + $y", outputStream: System.out
        }
    }
}


feature('write error of the command to a file') {
    task 'writeCommandError'
    category 'test'
}

task writeCommandError << {
    def tempFile = file(localTempPath())
    tempFile.withOutputStream { stream ->
        ssh.run {
            session(remotes.localhost) {
                execute "cat hoge || true", errorStream: stream
            }
        }
    }
    assert tempFile.text.contains('hoge')
}
